# -- 模板配置变量替换定义 --
# 此处配置的变量将用于具体服务的配置模板替换
# 可以将其加载为环境变量直接实现替换，也可以单独传递从而主程序的运行时环境不会保留这些变量；
# 该行为取决于启动参数的配置，具体参考相关 compose.yaml 文件的注释。

#### ========= 核心部分 ========= ####
# 配置模板目录，模板必须以 `.template` 结尾；
ENVWARP_TEMPLATE="/usr/local/etc/templates"
# 配置生成目录
ENVWARP_CONFDIR="/usr/local/etc/caddy"
# 配置生成后的执行命令（可选，对于容器运行一般是必选）
ENVWARP_EXECUTION="/usr/local/bin/caddy run --config  ${ENVWARP_CONFDIR}/Caddyfile.json"

# 注意：如果是容器化使用，以上应指定容器内映射路径，需要与 `compose.yaml` 挂载目标一致，一般无需修改！

# 健康检查地址（可选），本项目默认并未开启，具体参考 `HEALTHCHECK.md`
ENVWARP_CHECKURL="http://127.0.0.1/healthcheck"

#### ========= caddy 专用 ========= ####
# 内部 https 端口
# 注意，如果 xray reality 是偷别人的设置，请在这里取消引用，直接定义 8443 等内部 https 端口，也就是不该与 xray 产生关联
CADDY_INTERNAL_TLS_PORT=${XRAY_INBOUND_REALITY_TARGET:-8443}

# 站点根域名，用于 WEB 主页和申请 *.CADDY_DOMAIN_ROOT 的通配符证书，可写明文邮箱或者使用机密
CADDY_DOMAIN_ROOT="example.com"

# 证书注册账户，可写明文邮箱或者使用机密
CADDY_ISSUSRS_ACCOUNT_EMAIL="user@example.com"

# ZeroSSL EAB(外部账户绑定)信息，通过 https://app.zerossl.com/developer 申请
# 如果不使用 EAB，需删除配置模板中 `tls.automation.policies.issuers.external_account`
# 此时自动证书服务依然可用，只是你无法在 ZeroSSL 仪表盘查看自己的证书信息
CADDY_ZEROSSL_EAB_KID="file./run/secrets/zerossl_eab_kid"
CADDY_ZEROSSL_EAB_HMAC_KEY="file./run/secrets/zerossl_eab_hmac_key"

# 域名 DNS 提供商 TOKEN，如果你使用其他提供商，搜索配置模板对应变量进行修改
# !!!注意!!!
# 该变量名称结尾为 `_FILE`，envsubst-warp 启动器不会解析机密内容，原样传递给模板；
# 这是因为该插件支持直接从文件读取机密，而上述 EAB 配置则不支持该机制。
# 需第三方插件：github.com/caddy-dns/cloudflare
CADDY_DNS_PROVIDER_CLOUDFLARE_FILE="file./run/secrets/cloudflare_token"

#### ========= caddy 可选 API 服务 ========= ####
# 使用 caddy 作为前置，通过提供各种 API 或其他服务的域名，可写明文邮箱或者使用机密
CADDY_API_BACKEND_DOMAIN="api.example.com"

# 当前配置模板对这些 API 服务的设计是：
# 通过不同的路径前缀区分不同的服务，进行不同的上游反代以及参数传递；
# 可选的公共端点，不会检测 JWT 等身份鉴权，适合状态检查等；

# 需要注意：
# 路径前缀仅用于 caddy 阶段区分，调用上游时会将其移除；
# 比如 api.example.com/xray/get_data ，如果设置路径前缀为 /xray
# 则真正反代到上游的是 `/get_data`；当然你可以从配置模板中改变此逻辑。

# xray-api-bridge 后端服务
# 路径前缀
CADDY_API_BACKEND_XRAY_PREFIX="/xray"
# 公共端点（无需身份校验）
CADDY_API_BACKEND_XRAY_PUB_ENDPOINT="/status"
# OCR 后端服务反代地址，是 ip:port 还是 unix sock 视后端支持情况而定
CADDY_API_BACKEND_XRAY_UPSTREAM=${XRAY_API_BRIDGE_LISTEN}

# OCR 后端服务
CADDY_API_BACKEND_OCR_PREFIX="/ocr"
CADDY_API_BACKEND_OCR_PUB_ENDPOINT="/status"
CADDY_API_BACKEND_OCR_UPSTREAM="/dev/shm/ddddocr_http_api.sock"

#### ========= JWT 模块（API 网关）配置 ========= ####
# 需第三方模块：github.com/ggicci/caddy-jwt ，本项目默认集成
# 更强大的身份验证功能，可使用 github.com/greenpau/caddy-security
# 除了算法和密钥，其余字段几乎都是数组形式，可指定多个后端服务的必须数据；

# JWT 签名密钥（配置中的 sign_key 字段），可以是对称密钥或非对称公钥，公钥时其实可以公开，但建议使用机密存储；
# 插件支持文件机密读取，因此本变量名称以 `_FILE` 结尾；
# 生成方法：
# - 非对称 ES256
# openssl ecparam -name prime256v1 -genkey -noout -out ecc-private-key-legacy.pem  # 私钥/原始格式
# openssl pkey -in ecc-private-key-legacy.pem -out ecc-private-key-pkcs8.pem  # 私钥/保密，原始格式可删除
# openssl pkey -in ecc-private-key-pkcs8.pem -pubout -out ecc-public-key.pem  # 公钥/可公开，也是当前环境变量需要的值
# - 非对称 RS256
# openssl genpkey -algorithm RSA -out rsa-private-key.pem -pkeyopt rsa_keygen_bits:2048  # 私钥/保密
# openssl pkey -in rsa-private-key.pem -pubout -out rsa-public-key.pem  # 公钥/可公开，也是当前环境变量需要的值
# - 对称 HS256
# openssl rand -base64 32  # 双端统一/保密，也是当前环境变量需要的值
CADDY_JWT_SIGNATURE_KEY_FILE="file./run/secrets/jwt_signature_key"

# 签名算法（配置中的 sign_alg 字段），推荐：ES256 > RS256 > HS256
CADDY_JWT_SIGNATURE_ALGORITHM="ES256"

# 除上述外，该模块还支持以下参数，在当前配置模板中要么未启用，要么直接硬编码而没有设计环境变量，你可以自行按需设计：
# 签名与密钥 (Signature & Keys)：JWT 核心
#   sign_key 和 sign_alg - 见上述环境变量
#   jwk_url - 远程获取签名密钥，当前未启用；如果使用此方式则不该设置签名密钥字段；
# 载荷验证 (Payload Validation) ：
#   issuer_whitelist (签发者白名单)数组，哪个机构签发的 JWT，可自定义，模块配置为上面的 CADDY_API_BACKEND_DOMAIN
#   audience_whitelist (接收者白名单)数组，谁有权持有这个 JWT，可自定义，模块配置为上面的`上游路径前缀`
# 用户身份与元数据 (User Information)：
#   user_claims (用户身份声明)数组，将找到的第一个匹配值（默认 sub）映射到 caddy 的 {http.auth.user.id} 占位符，模块配置保持默认值；
#       如果你的上游服务需要用户身份信息，需要生成 JWT 时指定 sub = xxx，使用该字段传递会比使用查询参数/请求头等方式更好；
#   meta_claims (元数据声明)对象，这与验证无关，仅在验证后传递更多信息；
#       其中的 `key: value` 含义是：检索 JWT 中的 key（可点分嵌套），找到后映射为 caddy 的 {http.auth.user.<value>} 占位符
#       可参考配置文件，我们在 xray-api-bridge 的反代中将该值转换为查询参数的形式提交给上游，这是为了订阅服务合法，其他端点其实并不需要。
# JWT 的来源 (Location)：
# 注意这与 JWT 令牌本身无关，是本模块从何处获得 JWT 数据，支持三种方式：
# from_header、from_query、from_cookies，需要为你使用的方式配置存储 JWT 的键，当前模块配置仅开启了 from_header: Authorization
# 因此意味着你的请求必须包含： "Authorization: Bearer <JWT_token>" 这样的标头；

# 额外还有个对 JWT 十分重要的参数：过期时间，但这不属于本模块（验证端）的部分，你需要在生成端设置合理的 exp 参数，建议短期 API 服务使用较短的过期时间。

# 所有主流开发语言都有 JWT 生成模块，只要按照这里的验证定义生成合法的 JWT，即可使用 caddy 作为 API 网关实现身份鉴权。
# 本地调试推荐：https://github.com/mike-engel/jwt-cli
# jwt encode --kid "自定义头ID" --iss "签发机构" --aud "持有者" --sub "用户ID" --jti "自定义JWT-ID" --alg ES256 --exp="5m" --secret=@密钥路径 '{"uuid": ["uuid1", "uuid2"]}'
# 上述会生成一个 5 分钟有效的 JWT，可供本地 curl 发起调试，当然 xray-api-bridge 服务除了订阅端点，其他时候无需包含 uuid；

